<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最小生成树</title>
    <url>/2020/04/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="最小生成树-加权无向图"><a href="#最小生成树-加权无向图" class="headerlink" title="最小生成树 - 加权无向图"></a>最小生成树 - 加权无向图</h2><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>这里只简单的介绍一般情况下的最小生成树问题，因此最加权图数据做了一些规定：</p>
<ol>
<li>只考虑连通图(如果不满足会产生最小森林)</li>
<li>所有边的权重不同(不满足会出现多个最小生成树)</li>
</ol>
<h3 id="加权图数据结构"><a href="#加权图数据结构" class="headerlink" title="加权图数据结构"></a>加权图数据结构</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Edge&gt;[] _adj; <span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _v; <span class="comment">//结点数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _e; <span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 按文件数据生成一个加权无向图，</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="path"&gt;</span>图文件路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> line;</span><br><span class="line">            System.IO.StreamReader sr = <span class="keyword">new</span> System.IO.StreamReader(path);</span><br><span class="line">            _v = Convert.ToInt32(sr.ReadLine());</span><br><span class="line">            _e = <span class="number">0</span>;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;Edge&gt;[_v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _v; i++) &#123; _adj[i] = <span class="keyword">new</span> List&lt;Edge&gt;(); &#125;</span><br><span class="line">            <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] str = line.Split(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">int</span> a = Convert.ToInt32(str[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> b = Convert.ToInt32(str[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> w = (<span class="keyword">float</span>)Convert.ToDouble(str[<span class="number">2</span>]);</span><br><span class="line">                AddEdge(<span class="keyword">new</span> Edge(a,b,w));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> V =&gt; _v;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> E =&gt; _e;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>._v = v;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;Edge&gt;[v];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params">Edge e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e.Either, w = e.Other(v);</span><br><span class="line">            _adj[v].Add(e);</span><br><span class="line">            _adj[w].Add(e);</span><br><span class="line">            _e++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Adj</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> _adj[v].ToArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;Edge&gt; edges = <span class="keyword">new</span> List&lt;Edge&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _adj.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _adj[i].Count; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    edges.Add(_adj[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> edges.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Edge</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> _weight;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">//一个结点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> w; <span class="comment">//另一个结点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span>(<span class="params"><span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">float</span> weight</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>._weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> Weight =&gt; _weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Either =&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 取得不同于参数的另一个结点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Other</span>(<span class="params"><span class="keyword">int</span> vertex</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex == v) <span class="keyword">return</span> w;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) <span class="keyword">return</span> v;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不包含该顶点"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Edge other = (Edge)obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._weight &gt; other.Weight) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._weight &lt; other.Weight) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例的加权图数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4 5 .35</span><br><span class="line">4 7 .37</span><br><span class="line">5 7 .28</span><br><span class="line">0 7 .16</span><br><span class="line">1 5 .32</span><br><span class="line">0 4 .38</span><br><span class="line">2 3 .17</span><br><span class="line">1 7 .19</span><br><span class="line">0 2 .26</span><br><span class="line">1 2 .36</span><br><span class="line">1 3 .29</span><br><span class="line">2 7 .34</span><br><span class="line">6 2 .40</span><br><span class="line">3 6 .52</span><br><span class="line">6 0 .58</span><br><span class="line">6 4 .93</span><br></pre></td></tr></table></figure>

<h3 id="切分定理"><a href="#切分定理" class="headerlink" title="切分定理"></a>切分定理</h3><p>将加权图的结点分为两个部分：已经<strong>确定为最小生成树的结点</strong>和<strong>尚未加入最小生成树的结点</strong>，这连接这两部分的边中<strong>最小的一条边</strong>可以加入最小生成树。获得最小生成树的算法大都基于切分定理</p>
<h3 id="常用的算法："><a href="#常用的算法：" class="headerlink" title="常用的算法："></a>常用的算法：</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a><strong>Prim</strong>算法</h4><h5 id="延时Prim算法"><a href="#延时Prim算法" class="headerlink" title="延时Prim算法"></a>延时Prim算法</h5><p><strong>描述</strong>：从一个结点开始将与之关联的边加入一个最小堆，然后从最小堆中得到权重最小的边，将边加入用于表示最小生成树的队列，同时遍历与该边连接的另一个结点的邻接表，将边都加入最小堆，重复这个过程直到最小堆为空。<br><strong>API</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span>(<span class="params">EdgeWeightedGraph g</span>) <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph g, <span class="keyword">int</span> v</span>)  <span class="comment">//添加v的未访问的邻接结点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)  <span class="comment">//返回最小树边的数组</span></span></span><br></pre></td></tr></table></figure>
<p><strong>详细代码</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> SortFunction;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazyPrimMST</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span>[] marked;  <span class="comment">//是否检查过该节点</span></span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Edge&gt; mst; </span><br><span class="line">        <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span>(<span class="params">EdgeWeightedGraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.V];</span><br><span class="line">            mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">            pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</span><br><span class="line">            Visit(g, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Edge min = pq.DeleteMin();</span><br><span class="line">                <span class="keyword">int</span> v = min.Either, w = min.Other(v);</span><br><span class="line">                <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) <span class="keyword">continue</span>; <span class="comment">//跳过失效的边</span></span><br><span class="line">                mst.Enqueue(min);</span><br><span class="line">                <span class="keyword">if</span> (!marked[v]) Visit(g, v);</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) Visit(g, w);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加v的未访问的邻接结点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph g, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (Edge i <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[i.Other(v)]) pq.Insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> mst.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="即时Prim算法"><a href="#即时Prim算法" class="headerlink" title="即时Prim算法"></a>即时Prim算法</h5><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a><strong>Kruskal</strong>算法</h4>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>逆转裁判-成步堂合集</title>
    <url>/2020/03/30/%E9%80%86%E8%BD%AC%E8%A3%81%E5%88%A4-%E6%88%90%E6%AD%A5%E5%A0%82%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="逆转裁判-扣人心弦的逆转"><a href="#逆转裁判-扣人心弦的逆转" class="headerlink" title="逆转裁判-扣人心弦的逆转"></a>逆转裁判-扣人心弦的逆转</h1><p><img src="https://pic.downk.cc/item/5e819065504f4bcb0409bdd8.jpg" alt=""></p>
<a id="more"></a>

<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>最早就听室友说过这个游戏，但当时我秉着对avg无爱的心，也没有多去了解这个游戏，直到我看了沧桑丸的逆转裁判视频。在此十分感谢沧桑丸的视频，让我感受到了逆转裁判的剧情和音乐的迷人之处，让我没有错过一款这么好的游戏(逆转裁判nb！)</p>
<h2 id="特色之处"><a href="#特色之处" class="headerlink" title="特色之处"></a>特色之处</h2><p>作为一个把<strong>法庭</strong>当成舞台的游戏，逆转裁判让我对法庭产生了极大的误解。没错！说好地当律师，结果我成了个侦探+雄辩家。不过，这也正是逆转裁判处理地好的地方，如果你要拿一本法典在面前才能玩这个游戏，那这也不可能是一部好游戏了。<br><img src="https://pic.downk.cc/item/5e82edca504f4bcb04fe7923.jpg" alt=""><br><strong>法庭+调查</strong>是逆转地两个核心部分，现场部分整体来说就差不多是和一般的侦探相同，简单地收集线索，游戏在这过程中也会向你逐步地透露真相。但毕竟<strong>丸步堂</strong>是个律师，主要战场还是在法庭上，每次到了法庭才是游戏的重头戏。<strong>证言+威慑+指证</strong>配合bgm将整个法庭过程渲染得刺激澎湃，加上法庭上会通过设定好的对话让真相更加明显，法庭上的<strong>逆转</strong>便是这游戏最大的魅力所在，不仅实在<strong>证言上的逆转</strong>，更是<strong>剧情上的逆转</strong>，我想，<strong>逆转的瞬间</strong>所带来的刺激是玩家喜欢逆转的最重要的原因。</p>
<h2 id="游戏系统"><a href="#游戏系统" class="headerlink" title="游戏系统"></a>游戏系统</h2><ol>
<li><strong>调查部分</strong><br>就像前面说的，<strong>调查+法庭</strong>这是逆转的主要两个部分。现场的游玩部分比较单调，就是切换地点，在场景中调查以及和人物对话。在第二部加入了成步堂的<strong>魔法开锁</strong>，这相当与在现场部分加入了一个法庭的精简版玩法，在总体上能算得上是让调查过程多了一丝色彩。当然，调查过程中也有令人激动的时刻，那就是发现重要线索时，线索本身带来的意外感加上<strong>BGM的加持</strong>，使得调查过程中也能有情绪高涨的时刻</li>
<li><strong>法庭部分</strong><br>最最重要的部分，<strong>逆转bgm和后面一系列的追问</strong>是这个游戏最吸引我的部分，开庭时证人的冷静到后来谎言被揭穿时的慌张，加上这一过程bgm的变换，会给人一种<strong>破案+辩论</strong>的双重快感，真相也会随着不断地指证而渐渐明了。这一过程中游戏会引导你找出证人地破绽，再通过设置好地对话揭露真相。一般的侦探游戏在杀人犯会继续行凶地情况下进行游戏，但逆转裁判在法庭上光明正大地辩论举证，这对一些胆小的玩家十分友好(比如我)。发现真相给人的感觉虽然没有恐怖类侦探那种恐惧解除的心流，但玩家心流的会在追问和指证的过程中达到最高点，证人破绽越多，表现也会越慌张，这点有点像rpg游戏boss的<strong>阶段机制</strong>一样，不过不是像rpg那样，越到后面玩家越要谨慎。逆转的“boss阶段”反而会使玩家越来越兴奋，而使<strong>心流</strong>在此过程中成一个接近指数的增长。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>avg游戏的缺点本身就十分明显，那就是可重复游玩性，而逆转裁判又是线性剧情，因此<strong>可重复游玩性也是很低</strong>的（不过得益于这个固有缺陷，也能放手去激发玩家的爆发式心流了）。然后是容易出现<strong>剧情卡壳</strong>，调查过程中一旦错过一个证据，就可能会去找半天，在法庭也是一样，虽然有时候关键信息的字体会用不同颜色凸显出来，但有些判定还是有些过于刁钻了。</p>
<h2 id="综合评价-四星半"><a href="#综合评价-四星半" class="headerlink" title="综合评价:四星半"></a>综合评价:四星半</h2><ol>
<li><strong>游戏性■■■□□</strong><br>大部分avg游戏的游戏性可想而知。。。，但逆转这套特殊的法庭系统还是有点东西的，不过还是基本没啥重复游玩的价值</li>
<li><strong>剧情■■■■■</strong><br>很少有能一眼看透的剧情，加上游戏系统的加持，让剧情更有张力，第一，三部最后一节的剧情更是超级精彩。</li>
<li><strong>艺术表现■■■■□</strong><br>bgm特别棒，相信玩过的一听到逆转的bgm就忍不住拍桌子，人物性格也十分突出，不过第二部的bgm不太行，所以扣个半分。</li>
<li><strong>心流把控■■■■□</strong><br>不去特意解决avg游戏重复游玩的问题(通过选项达成多结局啥的)，干脆然玩家在第一次就能获得绝佳的刺激与震撼，但可能出现的卡关问题还是有待改进</li>
</ol>
]]></content>
      <tags>
        <tag>AVG</tag>
        <tag>玩后感</tag>
      </tags>
  </entry>
  <entry>
    <title>hello</title>
    <url>/2020/03/29/hello/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
