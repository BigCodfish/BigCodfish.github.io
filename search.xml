<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最短路径</title>
    <url>/2020/04/28/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="最短路径"><a class="header-anchor" href="#最短路径"></a>最短路径</h2>
<h4 id="最短路径的性质"><a class="header-anchor" href="#最短路径的性质"></a>最短路径的性质</h4>
<ol>
<li>路径是有向的</li>
<li>不需要所有边都可达</li>
<li><strong>负权重</strong>会使问题变得更复杂</li>
<li>最短路径不是唯一的</li>
</ol>
<p>这里讨论的是<strong>单点最短路径</strong>，即找出从一个起点到所有可达顶点的最短路径构成的<strong>最短路径树</strong>。</p>
<h4 id="有向加权图的数据结构"><a class="header-anchor" href="#有向加权图的数据结构"></a>有向加权图的数据结构</h4>
<p>有向边的结构比无向边简单，有确定的起点和终点<br>
<strong>有向边的结构</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DirectEdge</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> v;  <span class="comment">//起点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> w;  <span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DirectEdge</span>(<span class="params"><span class="keyword">int</span> form, <span class="keyword">int</span> to, <span class="keyword">double</span> weight</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.v = form;</span><br><span class="line">            <span class="keyword">this</span>.w = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Form =&gt; v;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> To =&gt; w;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> Weight =&gt; weight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>加权有向图的结构：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加权有向图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">private</span> List&lt;DirectEdge&gt;[] _adj; <span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> line;</span><br><span class="line">            System.IO.StreamReader sr = <span class="keyword">new</span> System.IO.StreamReader(path);</span><br><span class="line">            v = Convert.ToInt32(sr.ReadLine());</span><br><span class="line">            e = <span class="number">0</span>;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;DirectEdge&gt;[v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123; _adj[i] = <span class="keyword">new</span> List&lt;DirectEdge&gt;(); &#125;</span><br><span class="line">            <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] str = line.Split(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">int</span> a = Convert.ToInt32(str[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> b = Convert.ToInt32(str[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> w = (<span class="keyword">float</span>)Convert.ToDouble(str[<span class="number">2</span>]);</span><br><span class="line">                AddEdge(<span class="keyword">new</span> DirectEdge(a, b, w));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDigraph</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;DirectEdge&gt;[v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                _adj[i] = <span class="keyword">new</span> List&lt;DirectEdge&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            e = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params">DirectEdge edge</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _adj[edge.Form].Add(edge);</span><br><span class="line">            e++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> V =&gt; v;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> E =&gt; e;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;DirectEdge&gt; <span class="title">Adj</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> _adj[v];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将加权有向图转换为有向图，后面使用拓扑排序会用到</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Digraph <span class="title">ToDigraph</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Digraph g= <span class="keyword">new</span> Digraph(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _adj.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (DirectEdge e <span class="keyword">in</span> _adj[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    g.AddEdge(e.Form, e.To);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="最短路径的API"><a class="header-anchor" href="#最短路径的API"></a>最短路径的API</h4>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SP</span></span><br><span class="line">		SP(EdgeWeightedDigraph G,int s)  //构造函数</span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">DistTo</span>(<span class="params"><span class="keyword">int</span> v</span>)             <span class="comment">//s到v的距离，不存在时为无穷大</span></span></span><br><span class="line"><span class="function">		<span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)            <span class="comment">//是否可达</span></span></span><br><span class="line"><span class="function">		DirectEdge[] <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="最短路径的基础"><a class="header-anchor" href="#最短路径的基础"></a>最短路径的基础</h4>
<h5 id="Relaxation-松弛"><a class="header-anchor" href="#Relaxation-松弛"></a>Relaxation(松弛)</h5>
<p>初始化时将出起点以外的distTo都设置为Double.maxValue。Relax()就是比较记录中的距离(<strong>distTo[i]的值</strong>)和现在路径的距离(<strong>distTo[i]+edge.weight</strong>)，如果当前的值较小则更新数据。松弛也可以用于<strong>边的松弛</strong>：参数为有向边，一次仅松弛一条边，和<strong>节点的松弛</strong>：松弛节点的邻接表。</p>
<h5 id="最短路径的最优性条件"><a class="header-anchor" href="#最短路径的最优性条件"></a>最短路径的最优性条件</h5>
<p><strong>对从v到w的任意一条边e，有distTo[w]&lt;=distTo[v]+e.weight</strong><br>
<strong>判断路径是否为最短路径的全局条件和放松一条边的区部最优性是等价的。</strong> 如果你从起点开始，那么你所得到的路径全都满足松弛的条件，而反过来从一个已知的最短路径来看，这个最短路径的每一个结点也必须满足松弛的条件(感觉还是有点说不清楚😅)</p>
<h4 id="Dijkatra算法"><a class="header-anchor" href="#Dijkatra算法"></a>Dijkatra算法</h4>
<p><strong>适用范围：</strong> 权重为正的加权有向图。<br>
<strong>思路：</strong> 类似于<strong>Prim算法</strong>（每次在队列中添加一个权最小的边到最小生成树中），初始将除起点以外的边的distTo都设置为最大。然后将distTo更小的点加入最小路径并放松该结点。<br>
<strong>时间：</strong> 与<strong>ElogV</strong>成正比<br>
<strong>空间：</strong> 与<strong>V</strong>成正比<br>
<strong>源代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 求得正权重加权有向图的最短路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DijkstraSP</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> DirectEdge[] edgeTo;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">        <span class="keyword">private</span> IndexMinPQ&lt;<span class="keyword">double</span>&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span>(<span class="params"><span class="keyword">int</span> v, EdgeWeightedDigraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            edgeTo = <span class="keyword">new</span> DirectEdge[g.V];</span><br><span class="line">            distTo = <span class="keyword">new</span> <span class="keyword">double</span>[g.V];</span><br><span class="line">            pq = <span class="keyword">new</span> IndexMinPQ&lt;<span class="keyword">double</span>&gt;(g.V);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V; i++)</span><br><span class="line">                distTo[i] = Double.MaxValue;</span><br><span class="line">            distTo[v] = <span class="number">0</span>;</span><br><span class="line">            pq.Insert(v, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Relax(g, pq.DeleteMin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 松弛边，选择权更小的路径</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Relax</span>(<span class="params">EdgeWeightedDigraph g,<span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (DirectEdge edge <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> w = edge.To;</span><br><span class="line">                <span class="keyword">if</span> (distTo[v] + edge.Weight &lt; distTo[w])</span><br><span class="line">                &#123;</span><br><span class="line">                    distTo[w] = distTo[v] + edge.Weight;</span><br><span class="line">                    edgeTo[w] = edge;</span><br><span class="line">                    <span class="keyword">if</span> (pq.Contains(w)) pq.Change(w, distTo[w]);</span><br><span class="line">                    <span class="keyword">else</span> pq.Insert(w, distTo[w]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">DistTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> distTo[v];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> distTo[v] &lt; Double.MaxValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DirectEdge[] <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;DirectEdge&gt; edges = <span class="keyword">new</span> List&lt;DirectEdge&gt;();</span><br><span class="line">            edges.Add(edgeTo[v]);</span><br><span class="line">            <span class="keyword">int</span> w = v;</span><br><span class="line">            <span class="keyword">while</span> (edgeTo[w] != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                w = edgeTo[w].Form;</span><br><span class="line">                edges.Add(edgeTo[w]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> edges.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理无环加权有向图的最短路径"><a class="header-anchor" href="#处理无环加权有向图的最短路径"></a>处理无环加权有向图的最短路径</h4>
<p><strong>特点：</strong></p>
<ol>
<li>能在<strong>线性时间</strong>处理单点最短路径问题</li>
<li>能处理负权重的边</li>
<li>能解决相关问题，例如找到最长路径</li>
</ol>
<p><strong>思路：</strong> 按照<strong>拓扑排序</strong>的顺序放松顶点，假设有一个图：a-&gt;b-&gt;c-&gt;d，那么按这个顺序放松，任意两个点都满足最优性条件，因为当点v被放松后，distTo[v]不会在发生变化，因为按拓扑排序放松，不会再处理指向v的边，所以到所有可达点都加入后，最优性条件成立。<br>
<strong>源代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AcyclicSP</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> DirectEdge[] edgeTo;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span>(<span class="params">EdgeWeightedDigraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            edgeTo = <span class="keyword">new</span> DirectEdge[g.V];</span><br><span class="line">            distTo = <span class="keyword">new</span> <span class="keyword">double</span>[g.V];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V; i++) distTo[i] = Double.MaxValue;</span><br><span class="line"></span><br><span class="line">            Topological topological = <span class="keyword">new</span> Topological(g.ToDigraph());</span><br><span class="line">            distTo[topological.Order[<span class="number">0</span>]] = <span class="number">0</span>; <span class="comment">//起点dist为0</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">int</span> v <span class="keyword">in</span> topological.Order)</span><br><span class="line">            &#123;</span><br><span class="line">                Relax(g, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 松弛顶点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Relax</span>(<span class="params">EdgeWeightedDigraph g, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (DirectEdge edge <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> w = edge.To;</span><br><span class="line">                <span class="keyword">if</span> (distTo[v] + edge.Weight &lt; distTo[w])</span><br><span class="line">                &#123;</span><br><span class="line">                    distTo[w] = distTo[v] + edge.Weight;</span><br><span class="line">                    edgeTo[w] = edge;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同Dijkatra</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">DistTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span>&#123;&#125;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span>&#123;&#125;    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> DirectEdge[] <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="一般加权有向图的最短路径"><a class="header-anchor" href="#一般加权有向图的最短路径"></a>一般加权有向图的最短路径</h4>
<p><strong>遇到的问题</strong></p>
<ol>
<li><strong>负权重</strong>可能会使我们为了经过负权重绕弯，或者在遍历图后，有结点经过一条负权重的边后还能使路径变短</li>
<li><strong>负权重环</strong>绕负权重环走可以使路径变得任意小</li>
</ol>
<p><strong>解决负权重环的问题</strong>：如果某个结点可达，但路径上有一个结点属于负权重环，则将该路径设置为<strong>负无穷</strong></p>
<h5 id="Bellman-Ford算法"><a class="header-anchor" href="#Bellman-Ford算法"></a>Bellman-Ford算法</h5>
<p>在有V个结点的图中，取s为起点，将distTo[s]设置为0，其他distTo[]设置为无穷大。然后以任意顺序<strong>放松所有边</strong>，重复V轮。需要事件EV。<br>
<strong>可以通过队列改进Bellman-Ford算法</strong>：因为只有在上一轮中distTo的值发生的顶点指出的边才能改变其他distTo的值。所以可以使用一个队列记录distTo改变的值，每次将一个结点出队后放松他指出的边。<br>
<strong>负权重环的检测：</strong><br>
使用relax的次数大于结点数时，说明已经开始绕负权重环转圈了。<br>
<strong>源代码：</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BellmanFordSP</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">       <span class="keyword">private</span> DirectEdge[] edgeTo;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">bool</span>[] onQueue; <span class="comment">//结点是否已经入队，防止重复入队。</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> cost; <span class="comment">//Relax调用次数</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span>[] cycle; <span class="comment">//是否有负权重环</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span>(<span class="params">EdgeWeightedDigraph g, <span class="keyword">int</span> s</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           queue = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">           distTo = <span class="keyword">new</span> <span class="keyword">double</span>[g.V];</span><br><span class="line">           edgeTo = <span class="keyword">new</span> DirectEdge[g.V];</span><br><span class="line">           onQueue = <span class="keyword">new</span> <span class="keyword">bool</span>[g.V];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distTo.Length; i++)</span><br><span class="line">           &#123;</span><br><span class="line">               distTo[i] = Double.MaxValue;</span><br><span class="line">           &#125;</span><br><span class="line">           distTo[s] = <span class="number">0</span>;</span><br><span class="line">           queue.Enqueue(s);</span><br><span class="line">           onQueue[s] = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">while</span> (!HasNegativeCycle &amp;&amp; queue.Count &gt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> v = queue.Dequeue();</span><br><span class="line">               onQueue[v] = <span class="literal">false</span>;</span><br><span class="line">               Relax(g, v);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Relax</span>(<span class="params">EdgeWeightedDigraph g, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">foreach</span> (DirectEdge e <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> w = e.To;</span><br><span class="line">               <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.Weight)</span><br><span class="line">               &#123;</span><br><span class="line">                   distTo[w] = distTo[v] + e.Weight;</span><br><span class="line">                   edgeTo[w] = e;</span><br><span class="line">                   <span class="keyword">if</span> (!onQueue[w])</span><br><span class="line">                   &#123;</span><br><span class="line">                       queue.Enqueue(w);</span><br><span class="line">                       onQueue[w] = <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (cost++ % g.V == <span class="number">0</span>) FindNegativeCycle();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 找出负权重环</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FindNegativeCycle</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">int</span> v = edgeTo.Length;</span><br><span class="line">           EdgeWeightedDigraph spt = <span class="keyword">new</span> EdgeWeightedDigraph(v);</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++)</span><br><span class="line">               <span class="keyword">if</span> (edgeTo[i] != <span class="literal">null</span>)</span><br><span class="line">                   spt.AddEdge(edgeTo[i]);</span><br><span class="line">           <span class="comment">//书上用的一个定制的类，我没有找到，就用的有向环代替的</span></span><br><span class="line">           DirectCycle directCycle = <span class="keyword">new</span> DirectCycle(spt.ToDigraph());</span><br><span class="line">           cycle = directCycle.Cycle;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">bool</span> HasNegativeCycle =&gt; cycle != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">int</span>[] NegativeCycle =&gt; cycle;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">DistTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">return</span> distTo[v];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasPathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           <span class="keyword">return</span> distTo[v] &lt; Double.MaxValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> DirectEdge[] <span class="title">PathTo</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>       &#123;</span><br><span class="line">           List&lt;DirectEdge&gt; edges = <span class="keyword">new</span> List&lt;DirectEdge&gt;();</span><br><span class="line">           edges.Add(edgeTo[v]);</span><br><span class="line">           <span class="keyword">int</span> w = v;</span><br><span class="line">           <span class="keyword">while</span> (edgeTo[w] != <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               w = edgeTo[w].Form;</span><br><span class="line">               edges.Add(edgeTo[w]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> edges.ToArray();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>明日方舟-19年我最喜欢的手游</title>
    <url>/2020/04/20/%E6%98%8E%E6%97%A5%E6%96%B9%E8%88%9F-19%E5%B9%B4%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E6%89%8B%E6%B8%B8/</url>
    <content><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTlkNGFjMmMyYTlhODNiZTU1YjIxMDYuanBn?x-oss-process=image/format,png" alt=""></p>
<a id="more"></a>
<h3 id="相遇🐰"><a class="header-anchor" href="#相遇🐰"></a>相遇🐰</h3>
<p>三测时入坑，现在想起来三测的评分真是惨不忍睹，当时也是因为游戏荒才下了玩。而玩完三测的所有内容后，不禁对当时的低评分感到诧异。入眼便是设计优秀的ui，然后是优秀的人物服装，还有具有挑战性的关卡和吸引人的剧情。然后去看评论，发现诟病的全是高难度(如果面向一般玩家的话，三测难度确实高，但我这种抖m玩家还挺喜欢)和氪金体验差(迷惑行为大赏👍，也许这就是零氪玩家体验不到的枯燥生活吧)，当时甚至还在B站看到有人出视频说鹰角biss，这也深深提醒了我互联网中充斥这各种以主观表客观的内容(好像跑题了)</p>
<h3 id="回到正题"><a class="header-anchor" href="#回到正题"></a>回到正题</h3>
<p><strong>提纲：</strong><br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTlhNjEwYWMyYTlhODNiZTU1Y2JlMjMucG5n?x-oss-process=image/format,png" alt=""><br>
最令人感到意外的还是整个游戏在<strong>美学和文学性方面的统一</strong>，也就是说人物的样子和世界观很搭，人物和世界观的整体性很强，不像很多萌豚游戏一样，世界(dio？？？)惨的一批，但人物还穿的很漏，还天天亚萨西，虽说现在手游卖纸片人老婆👰是常规操作，但我相信比起没啥个性而只是卖肉的纸片人比起来，玩家更喜欢各种个性不同的老婆，即使她们穿得挺严实的。<br>
<img src="https://pic.downk.cc/item/5e9d4930c2a9a83be5599f54.jpg"></p>
<h3 id="初见的视觉惊艳"><a class="header-anchor" href="#初见的视觉惊艳"></a>初见的视觉惊艳</h3>
<p><strong>近未来，金属感，朋克</strong>，这些是arknights的美术风格给我的第一感觉，但其实现在很多手游但能给你这样的感觉，甚至还可以是3D的，但最重要的：arknights的角色风格与整体风格更加协调，许多游戏的整体风格也表现的好，但一看到角色就。。。。嗯，装得越少防御越高对吧。。。。对个🐔！但arknights的角色画得好多了，与整体得压抑感和厚重感对应，角色大多穿多层衣服，材质给人的感觉多是一种比较硬的面料并有塑料的反光性，很能烘托出整体的金属感。<br>
然后是菱角分明的UI和图标，<br>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTlkNDg3Y2MyYTlhODNiZTU1OGU0YWIuanBn?x-oss-process=image/format,png" alt=""><br>
我相信许多玩家在看到这些有设计感的要素时，就有一种想继续玩下去的欲望了。</p>
<h3 id="难得剧情有脑子的手游"><a class="header-anchor" href="#难得剧情有脑子的手游"></a>难得剧情有脑子的手游</h3>
<p><strong>剧情整体：</strong> 相信许多人在第一章就感受到了arknights剧情的魅力：真实，一般手游第一章的内容基本都是新手教程，arknights也是如此，不过打完就死了npc😱，而且是合理死亡的(这里指的不是去送人头)，而且ace给人的感觉就是一种大哥型角色，这种角色如果以一种保护队友的方式死亡的话，给人留下的印象还是会很深的。arknights也通过第一章告诉了玩家：咱们走的是写实剧情。<br>
<strong>人物刻画：</strong> npc之间的交流对于丰富npc的形象是十分重要的，arknights在这里也表现得很好，说实话，其实感觉玩家所扮演得角色在npc的地位（指文本量）中并没有其他npc高，这样npc就显得更加真实了，在这里特别是龙门的npc刻画得很好，其实想丰富npc，并不需要出那种单独得剧情事件（很多日厂就是好感到一定后可以看单独的事件），想鼠王和老魏的过去就可以从他们的叙旧中了解到，即使讲得不太清楚，但其实已经可以了解到他们曾经算得上是一起出生入死得战友了，还顺带可以想象一下龙门之前的大战。像这样的刻画其实还有很多，比如：陈和星熊中了解到星熊以前是黑社会，莫斯提马和能天使中知道能天使以前留长发❔❔❔<br>
<img src="https://pic.downk.cc/item/5e9d49d1c2a9a83be55a3de5.jpg"><br>
<strong>世界观：</strong> 我一直觉得世界观大多时候只是代表了一种游戏的风格，世界观给人一种很严谨的感觉并不意味着游戏整体能让人觉得自成一体。arknights的世界观总体也是这样，因为画风，人物与世界观切合，所以游戏塑造的世界才十分精彩。</p>
<h3 id="终于来到了令人头痛的游戏机制环节"><a class="header-anchor" href="#终于来到了令人头痛的游戏机制环节"></a>终于来到了令人头痛的游戏机制环节</h3>
<h4 id="战斗机制"><a class="header-anchor" href="#战斗机制"></a>战斗机制</h4>
<p>简单来说就是<strong>塔防</strong>，但在原来熟悉的塔防上做出了一些修改，其中很有意思的一点就是在单格放置的基础上加入了<strong>方向</strong>，在不新增加游戏要素情况下增加了操作的复杂度。这是我觉得arknights最有意思的一点创新，其次是<strong>少数单位的重复放置</strong>。要拿以前的游戏来作比较的话，最重要的就是植物大战僵尸和保卫萝卜类的塔防，还有一部分传统rpg的设定。</p>
<h5 id="和植物大战僵尸类似的放置方式"><a class="header-anchor" href="#和植物大战僵尸类似的放置方式"></a>和植物大战僵尸类似的放置方式</h5>
<p>我室友看到我玩arknights时，第一反应就是植物大战僵尸，<strong>矩阵式的摆放方式</strong>和通过<strong>摆放单位阻挡敌人</strong>前进，有<strong>生产cost的单位</strong>🌻，想不让人联想到植物大战僵尸都难。不过不同与他的地方也有：那就是<strong>敌人的路线</strong>和<strong>单位的攻击范围</strong>，这里就涉及到另一个游戏了。</p>
<h5 id="经典塔防的路线"><a class="header-anchor" href="#经典塔防的路线"></a>经典塔防的路线</h5>
<p>同样有着每关不同的敌人路线，放置在高台的单位，特定的攻击范围，Arknights还是很好地继承了传统塔防游戏的优点：通过设计路线和配置敌人让每一关的体验区别开来，不过Arknights在攻击范围上做了一些改进，让同一格上的攻击范围有了四种选择，进一步提高了策略性</p>
<h5 id="rpg的职业配置"><a class="header-anchor" href="#rpg的职业配置"></a>rpg的职业配置</h5>
<p>通俗点说就是<strong>战法牧</strong>铁三角，<strong>重装</strong>：抗线战士，<strong>医疗</strong>：回血，<strong>远程</strong>：物理输出，<strong>法师</strong>：魔法输出，<strong>近战</strong>:各具特色的地面输出。虽然还可以继续细分，但基本的结构还是rpg的那一套。这样的职业搭配一方面<strong>方便出新卡(有端联想)</strong>，同时也提高了作战的策略性，让塔防不是选攻击力高的单位放了。</p>
<h4 id="养成机制"><a class="header-anchor" href="#养成机制"></a>养成机制</h4>
<p>毕竟是一个要长期运营的游戏，而且还有抽卡要素，那养老婆当然是这游戏的重中之重啦！不过Arknights这点我也没觉得有很大的变动。不过还是有几个有意思的点：</p>
<ol>
<li>角色的进阶材料共通</li>
<li>包里不会同时出现两个同样的角色</li>
<li>辐射避难所？</li>
</ol>
<p>不过这两个也不是只有Arknight独有罢了。</p>
<h5 id="角色的进阶材料共通"><a class="header-anchor" href="#角色的进阶材料共通"></a>角色的进阶材料共通</h5>
<p>不用去刷特殊本获取角色碎片真的特别舒服(至少我是这样觉得的)，避免了抽到角色但培养不了角色的尴尬，也能在抽到角色后一口气升到顶。</p>
<h5 id="不会出现同样的角色"><a class="header-anchor" href="#不会出现同样的角色"></a>不会出现同样的角色</h5>
<p>这里提这个感觉优点偏题了，其实这种设置给我的感觉更像是人物塑造方面的，更能体现出角色的独立感。</p>
<h5 id="基建"><a class="header-anchor" href="#基建"></a>基建</h5>
<p>一般这种游戏都有一个这样的收取资源的小游戏（应该算小游戏吧），而基建的特点就是像辐射避难所？？？当然，还有收取的资源的数目还是很客观的，应该是吧关卡掉落的资源都集中到了基建和资源关卡中了，这样能让各个部分的职能更加清晰具体。</p>
<h4 id="关卡设计"><a class="header-anchor" href="#关卡设计"></a>关卡设计</h4>
<p>关卡设计中很重要的一点就是：关卡与玩家操控单位的<strong>互动</strong>。是否存在一些有<strong>两面性</strong>的要素(使用得好对玩家有利，使用的不好则有害)。作为一个塔防游戏，arknights在部分关卡中已经做得很好了。比如：地火+减速单位，落穴+位移技能，合理摆放障碍+持续掉血的敌方单位。通过使用这些关卡中的要素可以使有些关卡变得十分简单，而如果你没想到，那可能很高的练度也刚不过去。还有一些敌方单位也和地图有联系：寒气方块+雪怪小队。<br>
Arknights有这种<strong>不纯靠练度通过</strong>的关卡，也是他好玩的一个重要原因。毕竟现在太多手游把玩家的成就感来源限制在了抽卡和养老婆上，而忽视了游戏最本征和最应当下心思的地方。</p>
<h4 id="数值设计"><a class="header-anchor" href="#数值设计"></a>数值设计</h4>
<p>这个就有点复杂了，特别是这种卡牌类的游戏，以后有时间再去研究一下吧（咕咕咕咕）</p>
<h3 id="总结"><a class="header-anchor" href="#总结"></a>总结</h3>
<p>Arknights高于其他手游的地方在于：</p>
<ol>
<li>优秀的设计让游戏的元素统一于世界观</li>
<li>作为卡牌游戏，发掘出了一个比较好玩的战斗模式</li>
</ol>
<p>其实做到这些并不是难于上青天，只是太多厂商急于圈钱，优秀的人物和世界设计会让抽卡获取新角色更有乐趣，而好玩的模式可以让热度起来后评分不会掉下去，从而吸引更多玩家。希望以后能看到更多有设计感的手游吧，同时祝愿Arknight越做越好。</p>
]]></content>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/04/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="最小生成树-加权无向图（算法第四版）"><a class="header-anchor" href="#最小生成树-加权无向图（算法第四版）"></a>最小生成树 - 加权无向图（算法第四版）</h2>
<a id="more"></a>
<h3 id="约定"><a class="header-anchor" href="#约定"></a>约定</h3>
<p>这里只简单的介绍一般情况下的最小生成树问题，因此最加权图数据做了一些规定：</p>
<ol>
<li>只考虑连通图(如果不满足会产生最小森林)</li>
<li>所有边的权重不同(不满足会出现多个最小生成树)</li>
</ol>
<h3 id="加权图数据结构"><a class="header-anchor" href="#加权图数据结构"></a>加权图数据结构</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Edge&gt;[] _adj; <span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _v; <span class="comment">//结点数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> _e; <span class="comment">//边数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 按文件数据生成一个加权无向图，</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="path"&gt;</span>图文件路径<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">string</span> line;</span><br><span class="line">            System.IO.StreamReader sr = <span class="keyword">new</span> System.IO.StreamReader(path);</span><br><span class="line">            _v = Convert.ToInt32(sr.ReadLine());</span><br><span class="line">            _e = <span class="number">0</span>;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;Edge&gt;[_v];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _v; i++) &#123; _adj[i] = <span class="keyword">new</span> List&lt;Edge&gt;(); &#125;</span><br><span class="line">            <span class="keyword">while</span> ((line = sr.ReadLine()) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] str = line.Split(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">int</span> a = Convert.ToInt32(str[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> b = Convert.ToInt32(str[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">float</span> w = (<span class="keyword">float</span>)Convert.ToDouble(str[<span class="number">2</span>]);</span><br><span class="line">                AddEdge(<span class="keyword">new</span> Edge(a,b,w));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> V =&gt; _v;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> E =&gt; _e;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedGraph</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>._v = v;</span><br><span class="line">            _adj = <span class="keyword">new</span> List&lt;Edge&gt;[v];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddEdge</span>(<span class="params">Edge e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e.Either, w = e.Other(v);</span><br><span class="line">            _adj[v].Add(e);</span><br><span class="line">            _adj[w].Add(e);</span><br><span class="line">            _e++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Adj</span>(<span class="params"><span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> _adj[v].ToArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;Edge&gt; edges = <span class="keyword">new</span> List&lt;Edge&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _adj.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _adj[i].Count; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    edges.Add(_adj[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> edges.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Edge</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> _weight;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">//一个结点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> w; <span class="comment">//另一个结点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span>(<span class="params"><span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">float</span> weight</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.v = v;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">            <span class="keyword">this</span>._weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> Weight =&gt; _weight;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Either =&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 取得不同于参数的另一个结点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Other</span>(<span class="params"><span class="keyword">int</span> vertex</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertex == v) <span class="keyword">return</span> w;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (vertex == w) <span class="keyword">return</span> v;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不包含该顶点"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Edge other = (Edge)obj;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._weight &gt; other.Weight) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._weight &lt; other.Weight) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例的加权图数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4 5 .35</span><br><span class="line">4 7 .37</span><br><span class="line">5 7 .28</span><br><span class="line">0 7 .16</span><br><span class="line">1 5 .32</span><br><span class="line">0 4 .38</span><br><span class="line">2 3 .17</span><br><span class="line">1 7 .19</span><br><span class="line">0 2 .26</span><br><span class="line">1 2 .36</span><br><span class="line">1 3 .29</span><br><span class="line">2 7 .34</span><br><span class="line">6 2 .40</span><br><span class="line">3 6 .52</span><br><span class="line">6 0 .58</span><br><span class="line">6 4 .93</span><br></pre></td></tr></table></figure>
<h3 id="切分定理"><a class="header-anchor" href="#切分定理"></a>切分定理</h3>
<p>将加权图的结点分为两个部分：已经<strong>确定为最小生成树的结点</strong>和<strong>尚未加入最小生成树的结点</strong>，这连接这两部分的边中<strong>最小的一条边</strong>可以加入最小生成树。获得最小生成树的算法大都基于切分定理</p>
<h3 id="常用的算法："><a class="header-anchor" href="#常用的算法："></a>常用的算法：</h3>
<h4 id="Prim算法"><a class="header-anchor" href="#Prim算法"></a><strong>Prim</strong>算法</h4>
<h5 id="延时Prim算法"><a class="header-anchor" href="#延时Prim算法"></a>延时Prim算法</h5>
<p><strong>描述</strong>：从一个结点开始将与之关联的边加入一个最小堆，然后从最小堆中得到权重最小的边，将边加入用于表示最小生成树的队列，同时遍历与该边连接的另一个结点的邻接表，将边都加入最小堆，重复这个过程直到最小堆为空。<br>
<strong>所需空间：</strong> 与<strong>E</strong>成正比，<br>
<strong>所需时间：</strong> 与<strong>ElogE</strong>成正比(最坏情况)<br>
<strong>API</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span>(<span class="params">EdgeWeightedGraph g</span>) <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph g, <span class="keyword">int</span> v</span>)  <span class="comment">//添加v的未访问的邻接结点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)  <span class="comment">//返回最小树边的数组</span></span></span><br></pre></td></tr></table></figure>
<p><strong>详细代码</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> SortFunction;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazyPrimMST</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span>[] marked;  <span class="comment">//是否检查过该节点</span></span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Edge&gt; mst; </span><br><span class="line">        <span class="keyword">private</span> MinPQ&lt;Edge&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LazyPrimMST</span>(<span class="params">EdgeWeightedGraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.V];</span><br><span class="line">            mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">            pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</span><br><span class="line">            Visit(g, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Edge min = pq.DeleteMin();</span><br><span class="line">                <span class="keyword">int</span> v = min.Either, w = min.Other(v);</span><br><span class="line">                <span class="keyword">if</span> (marked[v] &amp;&amp; marked[w]) <span class="keyword">continue</span>; <span class="comment">//跳过失效的边</span></span><br><span class="line">                mst.Enqueue(min);</span><br><span class="line">                <span class="keyword">if</span> (!marked[v]) Visit(g, v);</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) Visit(g, w);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加v的未访问的邻接结点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph g, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (Edge i <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[i.Other(v)]) pq.Insert(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Edge[] <span class="title">Edges</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> mst.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="即时Prim算法"><a class="header-anchor" href="#即时Prim算法"></a>即时Prim算法</h5>
<p><strong>描述</strong>：从延迟的prim算法中我们可以看到无效的边(边的两端都已经加入了最小生成树)也被加入到了最小堆里，但每次寻找边时我们需要的只是<strong>树外的点到树结点的权值最小的边</strong>，因此可以只将树外点w连接到树的边中权值最小的那个加入到<strong>最小堆</strong>(实际上是使用的<strong>索引最小堆</strong>)当中，这样可以避免在最小堆出堆时再检查边的有效性。<br>
<strong>API：</strong> 同延时实现<br>
<strong>所需空间：</strong> 与<strong>V</strong>成正比，<br>
<strong>所需时间：</strong> 与<strong>ElogV</strong>成正比(最坏情况)<br>
<strong>详细代码</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SortFunction;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Prim</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Edge[] edgeTo;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span>[] marked;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">        <span class="keyword">private</span> IndexMinPQ&lt;<span class="keyword">double</span>&gt; pq; <span class="comment">//索引最小堆，方便在找到更小的边时进行替换</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Prim</span>(<span class="params">EdgeWeightedGraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            edgeTo = <span class="keyword">new</span> Edge[g.V];  <span class="comment">//记录点连接到生成树的边</span></span><br><span class="line">            marked = <span class="keyword">new</span> <span class="keyword">bool</span>[g.V]; </span><br><span class="line">            distTo = <span class="keyword">new</span> <span class="keyword">double</span>[g.V]; <span class="comment">//记录连接边的权值</span></span><br><span class="line">            pq = <span class="keyword">new</span> IndexMinPQ&lt;<span class="keyword">double</span>&gt;();</span><br><span class="line">            <span class="comment">//未赋值时设置为最大</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.V; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                distTo[i] = Double.MaxValue;</span><br><span class="line">            &#125;</span><br><span class="line">            distTo[<span class="number">0</span>] = <span class="number">0.0f</span>;</span><br><span class="line">            pq.Insert(<span class="number">0</span>, <span class="number">0.0f</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Visit(g, pq.DeleteMin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Visit</span>(<span class="params">EdgeWeightedGraph g, <span class="keyword">int</span> v</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            marked[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (Edge e <span class="keyword">in</span> g.Adj(v))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> w = e.Other(v);</span><br><span class="line">                <span class="keyword">if</span> (marked[w]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.Weight &lt; distTo[w])</span><br><span class="line">                &#123;</span><br><span class="line">                    edgeTo[w] = e;</span><br><span class="line">                    distTo[w] = e.Weight;</span><br><span class="line">                    <span class="keyword">if</span> (pq.Contains(w)) pq.Change(w, e.Weight);</span><br><span class="line">                    <span class="keyword">else</span> pq.Insert(w, e.Weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kruskal算法"><a class="header-anchor" href="#Kruskal算法"></a><strong>Kruskal</strong>算法</h4>
<p><strong>描述：</strong> 每次将权值最小的边加入<strong>最小堆</strong>中，然后依次出堆，直到树中有<strong>V-1条</strong>边为止(完成最小生成树)，每次出堆要对结点的<strong>连通性进行检查</strong>，防止形成环<br>
<strong>所需空间：</strong> 与<strong>E</strong>成正比<br>
<strong>所需时间：</strong> 与<strong>ElogE</strong>成正比(最坏情况)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SortFunction;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line">namespace 图</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KruskalMST</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Queue&lt;Edge&gt; mst;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span>(<span class="params">EdgeWeightedGraph g</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            mst = <span class="keyword">new</span> Queue&lt;Edge&gt;();</span><br><span class="line">            MinPQ&lt;Edge&gt; pq = <span class="keyword">new</span> MinPQ&lt;Edge&gt;();</span><br><span class="line">            <span class="keyword">foreach</span> (Edge e <span class="keyword">in</span> g.Edges()) pq.Insert(e);</span><br><span class="line">            UF uf = <span class="keyword">new</span> UF(g.V); <span class="comment">//uf可以进行连通性检查，本体是union-find算法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!pq.IsEmpty() &amp;&amp; mst.Count &lt; g.V - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Edge e = pq.DeleteMin();</span><br><span class="line">                <span class="keyword">int</span> v = e.Either, w = e.Other(v);</span><br><span class="line">                <span class="keyword">if</span> (uf.Connected(v, w)) <span class="keyword">continue</span>; <span class="comment">//如果这两个结点进通过边相连，则跳过</span></span><br><span class="line">                uf.Union(v, w);</span><br><span class="line">                mst.Enqueue(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Edge[] Edges =&gt; mst.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>逆转裁判-成步堂合集</title>
    <url>/2020/03/30/%E9%80%86%E8%BD%AC%E8%A3%81%E5%88%A4-%E6%88%90%E6%AD%A5%E5%A0%82%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<h1 id="逆转裁判-扣人心弦的逆转"><a href="#逆转裁判-扣人心弦的逆转" class="headerlink" title="逆转裁判-扣人心弦的逆转"></a>逆转裁判-扣人心弦的逆转</h1><p><img src="https://pic.downk.cc/item/5e819065504f4bcb0409bdd8.jpg" alt=""></p>
<a id="more"></a>

<h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><p>最早就听室友说过这个游戏，但当时我秉着对avg无爱的心，也没有多去了解这个游戏，直到我看了沧桑丸的逆转裁判视频。在此十分感谢沧桑丸的视频，让我感受到了逆转裁判的剧情和音乐的迷人之处，让我没有错过一款这么好的游戏(逆转裁判nb！)</p>
<h2 id="特色之处"><a href="#特色之处" class="headerlink" title="特色之处"></a>特色之处</h2><p>作为一个把<strong>法庭</strong>当成舞台的游戏，逆转裁判让我对法庭产生了极大的误解。没错！说好地当律师，结果我成了个侦探+雄辩家。不过，这也正是逆转裁判处理地好的地方，如果你要拿一本法典在面前才能玩这个游戏，那这也不可能是一部好游戏了。<br><img src="https://pic.downk.cc/item/5e82edca504f4bcb04fe7923.jpg" alt=""><br><strong>法庭+调查</strong>是逆转地两个核心部分，现场部分整体来说就差不多是和一般的侦探相同，简单地收集线索，游戏在这过程中也会向你逐步地透露真相。但毕竟<strong>丸步堂</strong>是个律师，主要战场还是在法庭上，每次到了法庭才是游戏的重头戏。<strong>证言+威慑+指证</strong>配合bgm将整个法庭过程渲染得刺激澎湃，加上法庭上会通过设定好的对话让真相更加明显，法庭上的<strong>逆转</strong>便是这游戏最大的魅力所在，不仅实在<strong>证言上的逆转</strong>，更是<strong>剧情上的逆转</strong>，我想，<strong>逆转的瞬间</strong>所带来的刺激是玩家喜欢逆转的最重要的原因。</p>
<h2 id="游戏系统"><a href="#游戏系统" class="headerlink" title="游戏系统"></a>游戏系统</h2><ol>
<li><strong>调查部分</strong><br>就像前面说的，<strong>调查+法庭</strong>这是逆转的主要两个部分。现场的游玩部分比较单调，就是切换地点，在场景中调查以及和人物对话。在第二部加入了成步堂的<strong>魔法开锁</strong>，这相当与在现场部分加入了一个法庭的精简版玩法，在总体上能算得上是让调查过程多了一丝色彩。当然，调查过程中也有令人激动的时刻，那就是发现重要线索时，线索本身带来的意外感加上<strong>BGM的加持</strong>，使得调查过程中也能有情绪高涨的时刻</li>
<li><strong>法庭部分</strong><br>最最重要的部分，<strong>逆转bgm和后面一系列的追问</strong>是这个游戏最吸引我的部分，开庭时证人的冷静到后来谎言被揭穿时的慌张，加上这一过程bgm的变换，会给人一种<strong>破案+辩论</strong>的双重快感，真相也会随着不断地指证而渐渐明了。这一过程中游戏会引导你找出证人地破绽，再通过设置好地对话揭露真相。一般的侦探游戏在杀人犯会继续行凶地情况下进行游戏，但逆转裁判在法庭上光明正大地辩论举证，这对一些胆小的玩家十分友好(比如我)。发现真相给人的感觉虽然没有恐怖类侦探那种恐惧解除的心流，但玩家心流的会在追问和指证的过程中达到最高点，证人破绽越多，表现也会越慌张，这点有点像rpg游戏boss的<strong>阶段机制</strong>一样，不过不是像rpg那样，越到后面玩家越要谨慎。逆转的“boss阶段”反而会使玩家越来越兴奋，而使<strong>心流</strong>在此过程中成一个接近指数的增长。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>avg游戏的缺点本身就十分明显，那就是可重复游玩性，而逆转裁判又是线性剧情，因此<strong>可重复游玩性也是很低</strong>的（不过得益于这个固有缺陷，也能放手去激发玩家的爆发式心流了）。然后是容易出现<strong>剧情卡壳</strong>，调查过程中一旦错过一个证据，就可能会去找半天，在法庭也是一样，虽然有时候关键信息的字体会用不同颜色凸显出来，但有些判定还是有些过于刁钻了。</p>
<h2 id="综合评价-四星半"><a href="#综合评价-四星半" class="headerlink" title="综合评价:四星半"></a>综合评价:四星半</h2><ol>
<li><strong>游戏性■■■□□</strong><br>大部分avg游戏的游戏性可想而知。。。，但逆转这套特殊的法庭系统还是有点东西的，不过还是基本没啥重复游玩的价值</li>
<li><strong>剧情■■■■■</strong><br>很少有能一眼看透的剧情，加上游戏系统的加持，让剧情更有张力，第一，三部最后一节的剧情更是超级精彩。</li>
<li><strong>艺术表现■■■■□</strong><br>bgm特别棒，相信玩过的一听到逆转的bgm就忍不住拍桌子，人物性格也十分突出，不过第二部的bgm不太行，所以扣个半分。</li>
<li><strong>心流把控■■■■□</strong><br>不去特意解决avg游戏重复游玩的问题(通过选项达成多结局啥的)，干脆然玩家在第一次就能获得绝佳的刺激与震撼，但可能出现的卡关问题还是有待改进</li>
</ol>
]]></content>
      <tags>
        <tag>AVG</tag>
        <tag>玩后感</tag>
      </tags>
  </entry>
</search>
